[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Explore my projects\n        See my hands-on experience across various concepts and applications.\n      \n    \n  \n    \n      \n      \n        View my resume\n        For a full background on my education and career.\n        CV\n      \n    \n  \n    \n      \n      \n        Get in touch\n        Discuss potential collaborations and opportunities.\n      \n    \n  \n\n\n\n\n\n\nTesting\ncontent here\n\n\nAbout this blog\nfdsfsdf\n\n\n\ntesting\ncontent here"
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "Projects\nHere are some of the projects I’ve worked on:\n\nProject 1\nProject 2 … and so on."
  },
  {
    "objectID": "posts/git-explained/index.html",
    "href": "posts/git-explained/index.html",
    "title": "Git Explained",
    "section": "",
    "text": "Background\n\nIn today’s fast-paced software development world, Git is not just a tool; it’s a fundamental skill. Not only does it help teams track and coordinate complex projects but its distributed nature distinguishes it from other SCM (source code management) tools. It’s no surprise that Git powers the majority of modern software projects, playing a vital role in development workflows. This guide delves into the core features of Git along with concepts including staging, branching and merging.\n\n\nWhat is Git\n\nAt its simplest, Git is software that runs on your computer, recording and tracking every modification you make to your files. This is especially crucial for files containing code, as it enables developers to keep a detailed record of every change. But Git is much more than a simple tracker; as described by Wikipedia:\n\n“Git is a distributed version control system that tracks changes in any set of computer files, usually used for coordinating work among programmers who are collaboratively developing source code during software development.”\n\nThis definition introduces the term “distributed version control system”. To break this down, A VCS (version control system) is a name given to a system responsible for recording changes made to files over time. Unlike traditional VCS, which rely on a central server to store all versions of a project, Git operates on a distributed model. Every developer’s computer holds a complete copy of the project history, enabling work to continue seamlessly even without a central server connection.\n\nUnderstanding Version Control\n\nA VCS archives every modification made to a file or set of files over time. This allows anyone to revert to a previous version, compare changes, or analyse the evolution of a project. Git’s distributed nature not only enhances project security, since every participant has a full backup but also significantly improves collaboration and flexibility. Developers can work independently on different features or fixes and later “merge” their changes without the risk of losing work or interfering with the main codebase.\n\n\nThe Power of Git\n\nWith Git, every clone of a repository is not just a snapshot of your project at a given time; it’s a comprehensive backup of your project’s entire history. This aspect is fundamental for resilient project management and enables a wide array of workflows that can be tailored to the needs of any development team.\n\n\n\nGit Repositories\n\nAt the heart of Git’s powerful version control capabilities is the concept of repositories, or “repos” for short. A Git repository is essentially a database of your project’s history, tracking changes to your files over time. This history is stored in a special directory called the .git folder, which is created when you initialise Git in your project.\n\n\n\n\n\n\nNote\n\n\n\nThe .git folder contains more than just files; it houses the entire history of changes, branch information, and more.\n\n\n\nLocal vs. Remote\n\nA local repository resides on your personal computer, allowing you direct access to your files and their revision history. In contrast, a remote repository is stored on a server accessible over the internet or a network, facilitating collaboration with others. Platforms like GitHub, GitLab, and Bitbucket are popular choices for hosting remote repositories.\n\n\nCollaborating with Remote Repos\n\nRemote repositories enable teams to work together on a project. By cloning a remote repo to your local machine, you gain access to the most recent version of the project. Changes made locally can be shared with the team by pushing them to the remote repository, ensuring everyone stays in sync.\n\n\nCommitting and Pushing Changes\n\nA commit represents a snapshot of your project at a moment in time, allowing you to track the evolution of your code and revert to previous states if necessary. With descriptive commit messages, you can create a readable history of the project development. Pushing commits to a remote repository shares your changes with the team, facilitating collaboration.\n\n\n\n\n\n\nNote\n\n\n\nGit requires your local repo to be up to date with the remote repo before allowing you to push any changes, ensuring a conflict-free workflow. If your colleagues have pushed updates to the repo while you were working on it locally, Git will ask you to first “pull” these changes, integrating them with your work, before you can “push” your commits.\n\n\n\n\n\nKey Features of Git\nGit’s unique combination features sets it apart from other VCS. These features are designed to enhance efficiency, reliability and flexibility in the modern development process, making Git an indispensable tool. From its speed and distributed architecture to its sophisticated branching model and beyond, Git’s capabilities address the complex needs of today’s software projects. In this section, we delve into the specific features that contribute to Git’s standing as the preferred VCS for so many professionals. Each of these features not only solves practical problems faced in software development but also opens up new possibilities for how teams can work together on code.\n\nFast\n\nOne of the features of Git that make it fast is that each user has a full local history of a repository and can create commits and inspect the file history without an internet connection. Additionally, most operations are performed locally, which makes Git a faster VCS alternative than centralised systems that require constant communication with a remote server.\n\n\nDistributed\n\nAs mentioned earlier, when working in a team each member gets a full copy of the repository when they clone it, along with a full history of the commits so far. This means that in the event of a crash there is no single point of failure with Git, as every user has a copy of the main server (unless there is only a single copy of the repository).\nIn terms of development, a distributed system makes it easier to scale an engineering team. For instance with a centralised VCS, if a developer breaks the branch which contains the production code, other developers won’t be able to commit their changes until this is resolved. However, with Git this isn’t an issue, as everyone can continue working in their local repositories.\n\n\nGit’s branching model\n\nOne of the unique aspects of Git that distinguish it from other SCM tools is its branching capabilities. Think of a branch as an isolated environment for experimenting with a new feature, fixing a bug or testing out an idea. If we are satisfied we can go ahead and merge it with the main branch. A local branch exists on the local user’s machine; the main branch typically contains the production code.\n\n\n\nExample of a Git repository, each circle represents a commit.\n\n\nUsers are encouraged to utilise multiple local branches that can be independent of each other for the reasons stated above (disposable experimentation, working on new features and trying out new ideas).\nAdditionally, it is not necessary to push all your local branches to the remote repository, you can decide which ones to share. Ultimately, this gives users the freedom to try out new ideas and alleviates the worry of having to plan when they are going to share them with the rest of the team.\n\n\n\n\n\n\nNote\n\n\n\nCreation, merging and deletion of branches is extremely fast (takes seconds) and is a straightforward process.\n\n\n\n\nStaging\n\nGit’s “staging area” is a pre-commit holding area which allows you to review and format changes before making a commit. This gives developers the flexibility to selectively stage certain files without making a commit for all the modified files. This functionality extends to giving user’s the ability to stage and commit particular parts of files e.g. certain functions. This is particularly useful for keeping your project’s history organised and making sure each commit reflects a single logical change.\nWhen working with Git, files can be in either one of three states:\n\nModified: Changes have been made to the file but have not been staged.\nStaged: A modified file in it’s current version has been prepared for the next commit snapshot.\nCommitted: The file has been stored in the local database.\n\n\n\nAny workflow\n\nA workflow is a recommendation for how to utilise Git for all members to accomplish work productively and consistently. Git’s distributed nature and intuitive branching system make it possible for an almost endless number of workflows to be implemented with relative ease. As Git is focused on flexibility there is no standardised process for how to interact with Git.\n\n\nData Integrity\n\nGit ensures the integrity of code history through cryptographic hashes (SHA-1). Each commit is checksummed, guaranteeing the history’s integrity and immutability. Checksumming in Git involves generating a unique SHA-1 hash for each set of changes or commit. This hash acts as a fingerprint for that particular commit, encapsulating not only the changes made but also the context of those changes, including who made them, when they were made, and in relation to what other commits. This SHA-1 hash is a 40-character string composed of hexadecimal characters (0-9 and a-f) and represents a virtually unique identifier for that commit. This security feature is crucial for maintaining the reliability of a codebase, and is not commonly supported with centralised VCS."
  },
  {
    "objectID": "posts/git-explained/index.html#git-is-fast",
    "href": "posts/git-explained/index.html#git-is-fast",
    "title": "Git Explained",
    "section": "Git is fast",
    "text": "Git is fast\nOne of the features of Git that make it fast is that each user has a full local history of a repository and can create commits and inspect the file history without an internet connection. Additionally, most operations are performed locally, which makes Git a faster VCS alternative than centralised systems that require constant communication with a remote server."
  },
  {
    "objectID": "posts/git-explained/index.html#git-is-distributed",
    "href": "posts/git-explained/index.html#git-is-distributed",
    "title": "Git Explained",
    "section": "Git is distributed",
    "text": "Git is distributed\nAs mentioned earlier, when working in a team each member gets a full copy of the repository when they clone it, along with a full history of the commits so far. This means that in the event of a crash there is no single point of failure with Git, as every user has a copy of the main server (unless there is only a single copy of the repository).\nIn terms of development, a distributed system makes it easier to scale an engineering team. For instance with a centralised VCS, if a developer breaks the branch which contains the production code, other developers won’t be able to commit their changes until this is resolved. However, with Git this isn’t an issue, as everyone can continue working in their local repositories."
  },
  {
    "objectID": "posts/git-explained/index.html#gits-branching-model",
    "href": "posts/git-explained/index.html#gits-branching-model",
    "title": "Git Explained",
    "section": "Git’s branching model",
    "text": "Git’s branching model\nOne of the unique aspects of Git that distinguish it from other SCM tools is its branching capabilities. Think of a branch as an isolated environment for experimenting with a new feature, fixing a bug or testing out an idea. If we are satisfied we can go ahead and merge it with the master branch. A local branch exists on the local user’s machine; the main branch typically contains the production code.\n\n\n\nExample of a Git repository, each circle represents a commit.\n\n\nUsers are encouraged to utilise multiple local branches that can be independent of each other for the reasons stated above (disposable experimentation, working on new features and trying out new ideas).\nAdditionally, it is not necessary to push all your local branches to the remote repository, you can decide which ones to share. Ultimately, this gives users the freedom to try out new ideas and alleviates the worry of having to plan when they are going to share them with the rest of the team. Another important thing to mention is that the creation, merging and deletion of branches is extremely fast (takes seconds) and easy."
  },
  {
    "objectID": "posts/git-explained/index.html#any-workflow",
    "href": "posts/git-explained/index.html#any-workflow",
    "title": "Git Explained",
    "section": "Any workflow",
    "text": "Any workflow\nA workflow is a recommendation for how to utilise Git for all members to accomplish work productively and consistently. Git’s distributed nature and intuitive branching system make it possible for an almost endless number of workflows to be implemented with relative ease. As Git is focused on flexibility there is no standardised process for how to interact with Git."
  },
  {
    "objectID": "posts/how-to-use-git/index.html",
    "href": "posts/how-to-use-git/index.html",
    "title": "How to use Git",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!"
  },
  {
    "objectID": "posts/how-to-use-git/index.html#background",
    "href": "posts/how-to-use-git/index.html#background",
    "title": "How to use Git",
    "section": "Background",
    "text": "Background\nGit is a distributed VCS (version control system) that tracks changes made to files and directories, enabling users to record project changes and go back to a specific version of tracked files at any given time. Since Git is mainly used via the command line interface, knowledge of relevant commands is crucial for using Git effectively.\nThere are two scenarios that we will walk through:\n\nUsing Git with a local repository to track changes made to an existing project on your local machine.\nDeveloping an existing remote project which exists outside of your local machine."
  },
  {
    "objectID": "posts/how-to-use-git/index.html#configuration",
    "href": "posts/how-to-use-git/index.html#configuration",
    "title": "How to use Git",
    "section": "Configuration",
    "text": "Configuration\nLocal configuration variables are important, as they provide a way to identify who is making what changes to the project code. This is especially useful if you’re working with other developers. To specify your Git configuration settings, use the following commands:\ngit config --global user.name \"John Doe\"\ngit config --global user.email \"johndoe@example.com\""
  },
  {
    "objectID": "posts/how-to-use-git/index.html#initialising-a-new-git-repository",
    "href": "posts/how-to-use-git/index.html#initialising-a-new-git-repository",
    "title": "How to use Git",
    "section": "Initialising a new Git Repository",
    "text": "Initialising a new Git Repository\nRunning the command:\ngit init\nWill create a hidden .git directory for your project, this is where Git stores all internal tracking for the current repository.\n\n\n\n\n\n\nNote\n\n\n\nBefore initialising a new Git repository ensure that you have navigated to the main folder that contains your project files.\n\n\nAfter initialising a new Git repository, you can use the command:\nls -a\nTo show all the hidden files and directories including the newly created .git directory, you should see a .git file."
  },
  {
    "objectID": "posts/how-to-use-git/index.html#working-directory",
    "href": "posts/how-to-use-git/index.html#working-directory",
    "title": "How to use Git",
    "section": "Working Directory",
    "text": "Working Directory\nThe working directory consists of files you are currently working on, this is where untracked and modified files reside."
  },
  {
    "objectID": "posts/how-to-use-git/index.html#staging-area",
    "href": "posts/how-to-use-git/index.html#staging-area",
    "title": "How to use Git",
    "section": "Staging Area",
    "text": "Staging Area\nYou can think of the staging area as a rough draft space where you organise and select all the files you want to be part of the next commit. For example, if you’ve made several changes across multiple files and you want to make multiple commits then you can stage the individual files and commit them in small chunks. This would make your commits more detailed and allow you to be more specific about what changes were made to the project.\n\nRepository\nOnce you are satisfied with the changes you’ve made you can go ahead and commit the staged files to your repository."
  },
  {
    "objectID": "posts/how-to-use-git/index.html#staging-files",
    "href": "posts/how-to-use-git/index.html#staging-files",
    "title": "How to use Git",
    "section": "Staging files",
    "text": "Staging files\nWe can view the files in our working directory that have been modified or are being tracked by using:\ngit status\nThis command returns the current branch you are on (master branch). Untracked files are in red, tracked files appear in green.\n\nExample screenshot\nTo add a file to the staging area use the command:\ngit add fileName\nTo add multiple files to the staging area you can specify the names of all the files with a space between each file name:\ngit add fileName1 fileName2\nOr you could stage all the files and directories in your project folder by using:\ngit add .\nOnce you have added the relevant files to the staging area, you can use git status again to ensure the correct files are in the staging area.\n\n\nScreenshot here\nNow we can see which file or files have been added to the staging area and the changes are ready to be committed."
  },
  {
    "objectID": "posts/how-to-use-git/index.html#unstaging-files",
    "href": "posts/how-to-use-git/index.html#unstaging-files",
    "title": "How to use Git",
    "section": "Unstaging Files",
    "text": "Unstaging Files\nTo remove a file from the staging area, use the following command.\ngit reset fileName\nAlternatively, you can use git reset to remove all files from the staging area."
  },
  {
    "objectID": "posts/how-to-use-git/index.html#making-commits",
    "href": "posts/how-to-use-git/index.html#making-commits",
    "title": "How to use Git",
    "section": "Making Commits",
    "text": "Making Commits\nIn Git, commits are considered checkpoints or snapshots of your project at the current state, essentially you are saving the current version of your code with every commit that you make. You can create as many commits as you need and can go back and forth between different versions of the project. Commits are typically created at different logical points, such as after adding a new feature or a bug-fix implementation.\n\n\n\n\n\n\nNote\n\n\n\nBefore you can commit a file you need to place it in the staging area first.\n\n\nTo commit a file use the command git commit -m \"commit messge\""
  },
  {
    "objectID": "posts/how-to-use-git/index.html#commit-message",
    "href": "posts/how-to-use-git/index.html#commit-message",
    "title": "How to use Git",
    "section": "Commit Message",
    "text": "Commit Message\n(Message that this is optional) The commit message should be a descriptive summary of the changes that you are committing to the repository. After you’ve made a commit you will see a summary displayed, similar to the one below."
  },
  {
    "objectID": "posts/how-to-use-git/index.html#commit-history",
    "href": "posts/how-to-use-git/index.html#commit-history",
    "title": "How to use Git",
    "section": "Commit History",
    "text": "Commit History\nTo view all the commits made for a project you can use: git log\nThis will return details for each commit including the unique generated hash, author, date & time the commit was made, along with the commit message.\n[Example here]"
  },
  {
    "objectID": "posts/how-to-use-git/index.html#reverting-to-a-previous-commit",
    "href": "posts/how-to-use-git/index.html#reverting-to-a-previous-commit",
    "title": "How to use Git",
    "section": "Reverting to a previous commit",
    "text": "Reverting to a previous commit\nThe commit hash can be used to go back to a previous version of the project by using the command: git checkout &lt;commit_hash&gt;\nWhere commit_hash is the hash of a previous commit that you want to revert to. As mentioned above the commit hash of all the commits can be retrieved by using git log.\nYou can return to the latest version of the project files by using the command: git checkout main"
  },
  {
    "objectID": "posts/how-to-use-git/index.html#creating-a-new-branch",
    "href": "posts/how-to-use-git/index.html#creating-a-new-branch",
    "title": "How to use Git",
    "section": "Creating a new branch",
    "text": "Creating a new branch\nTo create a new branch, use the command: git branch &lt;new_branch&gt;\nIt’s good practice to create a development branch for adding new features and experimenting with code, once everything is working as expected you can merge it with the master branch."
  },
  {
    "objectID": "posts/how-to-use-git/index.html#switching-between-branches",
    "href": "posts/how-to-use-git/index.html#switching-between-branches",
    "title": "How to use Git",
    "section": "Switching between branches",
    "text": "Switching between branches\nCreating a new branch does not automatically switch to that branch, to do this you will need to use the command: git checkout &lt;branch_name\nThe commits made on one branch will be independent of changes made on all other branches unless you decide to merge these changes later on. You can create a new branch and switch to it simultaneously by using git checkout with the -b flag: git checkout -b &lt;new_beanch&gt;\nTo return to the main branch, run: git checkout main"
  },
  {
    "objectID": "posts/how-to-use-git/index.html#deleting-a-branch",
    "href": "posts/how-to-use-git/index.html#deleting-a-branch",
    "title": "How to use Git",
    "section": "Deleting a branch",
    "text": "Deleting a branch\nIf you’re satisfied with the changes made on an individual branch you can merge with another branch by using:\ngit branch -d &lt;branch_name&gt;"
  },
  {
    "objectID": "posts/how-to-use-git/index.html#merging-a-branch",
    "href": "posts/how-to-use-git/index.html#merging-a-branch",
    "title": "How to use Git",
    "section": "Merging a Branch",
    "text": "Merging a Branch\nIf you’re satisfied with the changes made on an individual branch you can merge with another branch by using:\ngit merge &lt;branch_name&gt; For example, you may have implemented a bug fix and want to merge this with the stable branch of your code (usually the master branch). branch_name is the branch you want to integrate into the current one you are on."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Stan Karzhev",
    "section": "",
    "text": "How to use Git\n\n\n\n\n\n\nDevelopment\n\n\n\n\n\n\n\n\n\nNov 23, 2023\n\n\nStan Karzhev\n\n\n\n\n\n\n\n\n\n\n\n\nGit Explained\n\n\n\n\n\n\ncode\n\n\n\nA brief introductory guide on the popular version control system, Git.\n\n\n\n\n\nNov 5, 2023\n\n\nStan Karzhev\n\n\n\n\n\n\nNo matching items"
  }
]